---
title: "RDA_our_method"
author: "Zitong Zhang"
# date: "12/12/2021"
output: 
  html_document:
    code_folding: hide
params: 
  subj_name: "func_20150417"
  data_folder: "../../Results/Rdata/RDA_v3/CDF_v2_specifyNclus_Nrestart10_totaltime336/"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, include=FALSE}
# Import functions --------------------------------------------------------

# rm(list=ls())
file_path = "../Functions"
file.sources = list.files(path = file_path, pattern = "*.R$", full.names = TRUE)
sapply(file.sources, source)

library(tidyverse)
library(gridExtra)
library(R.matlab)
library(data.table)
library(plotly)

```

## Read in network information for the L/R side 
```{r}
# Get network information for the L/R side 
path = paste0("../../Processed_FunctionalData/",params$subj_name,"/")
path_vec = c(path)

edge_time_mat_list = vector(mode = "list", length = 2)
locs_mat_list = vector(mode = "list", length = 2)
mnx_vec_list = vector(mode = "list", length = 2)
dFF_mat_list = vector(mode = "list", length = 2)
iso_inds_list = vector(mode = "list", length = 2)
non_iso_inds_list = vector(mode = "list", length = 2)


for(m in 1:length(path_vec)){ 
  path = path_vec[m]
  
  ### Read information from data
  edge_time_mat = as.matrix(read.csv(paste(path, '/EdgeTime.csv', sep='')))
  edge_time_mat = edge_time_mat[,-1]
  
  avai.inds = as.matrix(read.csv(paste(path,'/AvaiNeurons.csv',sep='')))
  avai.inds = avai.inds[,-1];
  
  locs.all = as.matrix(read.csv(paste(path,'/locs_all.csv',sep='')))
  locs.all = locs.all[,-1]
  locs_mat = locs.all[avai.inds,]
  
  mnx.all = as.matrix(read.csv(paste(path,'/mnx.csv',sep='')))
  mnx.all = mnx.all[,-1]
  mnx_vec = mnx.all[avai.inds]
  
  dFF.all = as.matrix(fread(paste(path,'/dFF.csv',sep='')))
  dFF.all = dFF.all[,-1]
  dFF_mat = dFF.all[avai.inds,]
  
  ### Split each zebrafish into left and right
  inds_L = which(locs_mat[,2]<0)
  inds_R = which(locs_mat[,2]>0)
  
  edge_time_mat_L = edge_time_mat[inds_L, inds_L]
  edge_time_mat_R = edge_time_mat[inds_R, inds_R]
  
  locs_mat_L = locs_mat[inds_L,]
  locs_mat_R = locs_mat[inds_R,]
  
  mnx_vec_L = mnx_vec[inds_L]
  mnx_vec_R = mnx_vec[inds_R]
  
  dFF_mat_L = dFF_mat[inds_L,]
  dFF_mat_R = dFF_mat[inds_R,]
  
  
  iso_inds_L = which(rowSums(edge_time_mat_L<Inf)<=0)
  iso_inds_R = which(rowSums(edge_time_mat_R<Inf)<=0)
  
  non_iso_inds_L = setdiff(1:nrow(edge_time_mat_L), iso_inds_L)
  non_iso_inds_R = setdiff(1:nrow(edge_time_mat_R), iso_inds_R)
  
  # ### Not remove top nodes
  # avai_inds_L = non_iso_inds_L
  # avai_inds_R = non_iso_inds_R
  # edge_time_mat_L = edge_time_mat_L[non_iso_inds_L, non_iso_inds_L]
  # edge_time_mat_R = edge_time_mat_R[non_iso_inds_R, non_iso_inds_R]
  
  ### Remove top nodes
  avai_inds_L = which(rowSums(edge_time_mat_L<Inf)>0 & locs_mat_L[,3]<=64)
  avai_inds_R = which(rowSums(edge_time_mat_R<Inf)>0 & locs_mat_R[,3]<=64)
  edge_time_mat_L = edge_time_mat_L[avai_inds_L, avai_inds_L]
  edge_time_mat_R = edge_time_mat_R[avai_inds_R, avai_inds_R]

  edge_time_mat_list[c(2*m-1,2*m)] = list(edge_time_mat_L, edge_time_mat_R)
  locs_mat_list[c(2*m-1,2*m)] = list(locs_mat_L, locs_mat_R)
  mnx_vec_list[c(2*m-1,2*m)] = list(mnx_vec_L, mnx_vec_R)
  dFF_mat_list[c(2*m-1,2*m)] = list(dFF_mat_L, dFF_mat_R)
  
  iso_inds_list[c(2*m-1,2*m)] = list(iso_inds_L, iso_inds_R)
  non_iso_inds_list[c(2*m-1,2*m)] = list(non_iso_inds_L, non_iso_inds_R)
  
}

```

## ICL chooses 5 clusters for both spines
```{r}
### Read in data analysis results
# data_folder = paste0(params$data_folder, params$subj_name, "/") 
data_folder = "../../Results/Rdata/RDA_v3/CDF_v1_selectNclus_Nrestart20_totaltime336/"
subj_name = "func_20150417"
data_folder = paste0(data_folder, subj_name, "/") 
path_vec = list.files(data_folder, full.names = TRUE, recursive = TRUE)

res_list = vector(mode = "list", length = length(path_vec))

for(m in 1:length(path_vec)){ 
  path = path_vec[m]
  ### Read in results from data
  load(path)
  res_list[[m]] = res
}


### Collect from all subjects: clusters_list, center_pdf_array, v_vec
clusters_list = lapply(res_list, function(res) res$clusters_list)
center_pdf_array_list = lapply(res_list, function(res) res$center_pdf_array)
v_vec_list = lapply(res_list, function(res) res$v_vec)
t_vec = res$t_vec
n0_mat_list = lapply(v_vec_list, function(v_vec) n0_vec2mat(n0_vec = v_vec/(t_vec[2]-t_vec[1])))


### Get connecting probabilities
order_clus_1 = order(rowSums(apply(center_pdf_array_list[[1]], 
      MARGIN = c(1,2),
      function(vec)sum(vec*(t_vec[2]-t_vec[1])))), 
      decreasing = TRUE)
order_clus_2 = order(rowSums(apply(center_pdf_array_list[[2]], 
      MARGIN = c(1,2),
      function(vec)sum(vec*(t_vec[2]-t_vec[1])))), 
      decreasing = TRUE)

membership_list_Nclus5 = lapply(clusters_list, clus2mem)
membership_list_Nclus5[[1]] = clus2mem(clusters_list[[1]][order_clus_1])
membership_list_Nclus5[[2]] = clus2mem(clusters_list[[2]][order_clus_2])

### Visualize estimated connecting intensities 
clus_size_list = lapply(clusters_list, function(clusters)sapply(clusters,length))

pdf_array_1 = center_pdf_array_list[[1]][order_clus_1,order_clus_1, ,drop=FALSE][1:4,1:4,]
pdf_array_2 = center_pdf_array_list[[2]][order_clus_2,order_clus_2, ,drop=FALSE][1:4,1:4,]

### Manually shift intensities and time shifts
global_shift = mean(c(max(which(cumsum(pdf_array_2[1,1,])<50/100)) -
                      max(which(cumsum(pdf_array_1[1,1,])<50/100)),
                    max(which(cumsum(pdf_array_2[1,2,])<50/100)) -
                      max(which(cumsum(pdf_array_1[1,2,])<50/100)),
                    max(which(cumsum(pdf_array_2[2,2,])<50/100)) -
                      max(which(cumsum(pdf_array_1[2,2,])<50/100))
                    ))
# global_shift = max(which(cumsum(pdf_array_2[1,1,])<50/100)) - max(which(cumsum(pdf_array_1[1,1,])<50/100))
pdf_array_2[,,1:(length(t_vec)-global_shift)] = pdf_array_2[,,(global_shift+1):length(t_vec)]
pdf_array_2[,,(length(t_vec)-global_shift+1):length(t_vec)] = 0
v_vec_list[[2]] = v_vec_list[[2]] + global_shift*(t_vec[2]-t_vec[1])

pdf_array_list = list(pdf_array_1, pdf_array_2)
clus_size_vec_1 = clus_size_list[[1]][order_clus_1][1:4]
clus_size_vec_2 = clus_size_list[[2]][order_clus_2][1:4]
clus_size_list[[1]][order_clus_1] -> clus_size_Nclus5_L
clus_size_list[[2]][order_clus_2] -> clus_size_Nclus5_R
tmp = plot_pdf_array_v3(pdf_array_list = pdf_array_list,
                       clus_size_vec_1 = clus_size_vec_1,
                       clus_size_vec_2 = clus_size_vec_2,
                       t_vec = t_vec,
                       y_lim = c(-0.01,max(unlist(pdf_array_list))))
g_list = tmp$g_list
layout_mat = matrix(nrow=nrow(pdf_array_2),ncol=nrow(pdf_array_2))
layout_mat[lower.tri(layout_mat, diag = TRUE)] = seq(length(g_list))
g = arrangeGrob(grobs=g_list, layout_matrix=layout_mat)
grid.arrange(g)

# big.df = tmp$big.df
# inter_quan_len_df = big.df %>%
#   mutate(inter_quan_len = quantile_95-quantile_5) %>%
#   select(ind_subj, clus.pair, inter_quan_len) %>%
#   group_by(clus.pair, ind_subj) %>%
#   summarise(inter_quan_len=unique(inter_quan_len)) %>%
#   ungroup()
# print(inter_quan_len_df)

```

- In terms of connecting probability, the similarity between first two clusters on Left and Right spine is larger than the similarity between Left and Right spine.

- There are two small clusters on Left spine and three clusters on Right spine, which might lead to large variance in result. Nnodes with similar behavior might be clustered to different clusters due to their different connectivity with small clusters.  

## Try 4 clusters
### Estimated intensities: (color code needs to be changed)
```{r}
### Read in data analysis results ----
# data_folder = paste0(params$data_folder, params$subj_name, "/") 
data_folder = "../../Results/Rdata/RDA_v3/CDF_v2_specifyNclus_Nrestart20_totaltime336/"
subj_name = "func_20150417"
data_folder = paste0(data_folder, subj_name, "/") 
path_vec = list.files(data_folder, full.names = TRUE, recursive = TRUE)

res_list = vector(mode = "list", length = length(path_vec))

for(m in 1:length(path_vec)){ 
  path = path_vec[m]
  ### Read in results from data
  load(path)
  res_list[[m]] = res
}


### Collect from all subjects: clusters_list, center_pdf_array, v_vec
clusters_list = lapply(res_list, function(res) res$clusters_list)
center_pdf_array_list = lapply(res_list, function(res) res$center_pdf_array)
v_vec_list = lapply(res_list, function(res) res$v_vec)
t_vec = res$t_vec
n0_mat_list = lapply(v_vec_list, function(v_vec) n0_vec2mat(n0_vec = v_vec/(t_vec[2]-t_vec[1])))

### Fix spike intensity 
for (ind in 1:length(center_pdf_array_list)) {
  if (dim(center_pdf_array_list[[ind]])[3]<length(t_vec)) {
    center_pdf_array_list[[ind]] = get_center_pdf_array_v2(edge_time_mat_list = edge_time_mat_list[ind], clusters_list = clusters_list[ind], n0_mat_list = n0_mat_list[ind], t_vec = t_vec)
}
}

### Visualize estimated intensities ----
### Get connecting probabilities
order_clus_1 = order(rowSums(apply(center_pdf_array_list[[1]], 
      MARGIN = c(1,2),
      function(vec)sum(vec*(t_vec[2]-t_vec[1])))), 
      decreasing = TRUE)
order_clus_2 = order(rowSums(apply(center_pdf_array_list[[2]], 
      MARGIN = c(1,2),
      function(vec)sum(vec*(t_vec[2]-t_vec[1])))), 
      decreasing = TRUE)

membership_list_Nclus4 = lapply(clusters_list, clus2mem)
membership_list_Nclus4[[1]] = clus2mem(clusters_list[[1]][order_clus_1])
membership_list_Nclus4[[2]] = clus2mem(clusters_list[[2]][order_clus_2])

### Visualize estimated connecting intensities 
clus_size_list = lapply(clusters_list, function(clusters)sapply(clusters,length))

pdf_array_1 = center_pdf_array_list[[1]][order_clus_1,order_clus_1, ,drop=FALSE][1:3,1:3,]
pdf_array_2 = center_pdf_array_list[[2]][order_clus_2,order_clus_2, ,drop=FALSE][1:3,1:3,]

### Manually shift intensities and time shifts
# global_shift_1 = max(which(cumsum(pdf_array_1[1,1,])<5/100))
# global_shift_2 = max(which(cumsum(pdf_array_2[1,1,])<5/100))
# final_shift = 
global_shift = mean(c(max(which(cumsum(pdf_array_2[1,1,])<50/100)) -
                      max(which(cumsum(pdf_array_1[1,1,])<50/100)),
                    max(which(cumsum(pdf_array_2[1,2,])<50/100)) -
                      max(which(cumsum(pdf_array_1[1,2,])<50/100)),
                    max(which(cumsum(pdf_array_2[2,2,])<50/100)) -
                      max(which(cumsum(pdf_array_1[2,2,])<50/100))
                    ))
global_shift_1 = 10
global_shift_2 = global_shift_1 + global_shift

pdf_array_1[,,1:(length(t_vec)-global_shift_1)] = pdf_array_1[,,(global_shift_1+1):length(t_vec)]
pdf_array_1[,,(length(t_vec)-global_shift_1+1):length(t_vec)] = 0
v_vec_list[[1]] = v_vec_list[[1]] + global_shift_1*(t_vec[2]-t_vec[1])

pdf_array_2[,,1:(length(t_vec)-global_shift_2)] = pdf_array_2[,,(global_shift_2+1):length(t_vec)]
pdf_array_2[,,(length(t_vec)-global_shift_2+1):length(t_vec)] = 0
v_vec_list[[2]] = v_vec_list[[2]] + global_shift_2*(t_vec[2]-t_vec[1])

pdf_array_list = list(pdf_array_1, pdf_array_2)
clus_size_vec_1 = clus_size_list[[1]][order_clus_1][1:3]
clus_size_vec_2 = clus_size_list[[2]][order_clus_2][1:3]
tmp = plot_pdf_array_v3(pdf_array_list = pdf_array_list,
                       clus_size_vec_1 = clus_size_vec_1,
                       clus_size_vec_2 = clus_size_vec_2,
                       t_vec = t_vec,
                       y_lim = c(-0.01,max(unlist(pdf_array_list))))
g_list = tmp$g_list
layout_mat = matrix(nrow=nrow(pdf_array_2),ncol=nrow(pdf_array_2))
layout_mat[lower.tri(layout_mat, diag = TRUE)] = seq(length(g_list))
g = arrangeGrob(grobs=g_list, layout_matrix=layout_mat)
grid.arrange(g)

clus_size_list[[1]][order_clus_1]
clus_size_list[[2]][order_clus_2]

# big.df = tmp$big.df
# inter_quan_len_df = big.df %>%
#   mutate(inter_quan_len = quantile_95-quantile_5) %>%
#   select(ind_subj, clus.pair, inter_quan_len) %>%
#   group_by(clus.pair, ind_subj) %>%
#   summarise(inter_quan_len=unique(inter_quan_len)) %>%
#   ungroup()
# print(inter_quan_len_df)


```

- Compared with 5-cluster result, consistency in connecting probabilities between Left and Right spines is improved. The connecting probabilities $p_{1,3}>p_{2,3}$ for both Left and Right spine.

For both Left and Right spine, there is a 2-node cluster but not shown in above plot. The small cluster on Left and Right spines have similar connecting probabilities:
```{r}
prob_vec_L = round(apply(center_pdf_array_list[[1]][order_clus_1,order_clus_1, ,drop=FALSE][4,,], 1, function(f)sum(f*(t_vec[2]-t_vec[1]))), digits = 2)

prob_vec_R = round(apply(center_pdf_array_list[[2]][order_clus_2,order_clus_2, ,drop=FALSE][4,,], 1, function(f)sum(f*(t_vec[2]-t_vec[1]))), digits = 2)

cbind(Conn_prob_Left = prob_vec_L, Conn_prob_Right = prob_vec_R)
```

### Changes in  memberships from 5 to 4 clusters
```{r}
### mnx decomposition  ----

data = tibble(subj=rep(1:length(membership_list_Nclus4),sapply(membership_list_Nclus4,length)),
              membership_Nclus4=unlist(membership_list_Nclus4),
              membership_Nclus5=unlist(membership_list_Nclus5)
              )

data_2 = data %>%
  mutate(membership_Nclus4=factor(membership_Nclus4,levels=1:max(membership_Nclus4)), 
         membership_Nclus5=factor(membership_Nclus5,levels=max(membership_Nclus5):1))

data_2_left = data_2 %>% filter(subj==1) 
data_2_right = data_2 %>% filter(subj==2) 

fill_color = c(`0`=palette()[8],
               `1`=palette()[2],
               `2`=palette()[3],
               `3`=palette()[4],
               `4`=palette()[5],
               `5`=palette()[6])
### Left spine
g1 = data_2_left %>%
  # mutate(membership=factor(membership,levels=c(0,1,2,3,4))) %>%
  ggplot(mapping = aes(fill=membership_Nclus5,x=membership_Nclus4)) +
  scale_fill_manual(values=fill_color) +
  geom_bar(position="stack") +
  # geom_text(data = data_2_left %>%
  #             count(membership_Nclus4, membership_Nclus5) %>% group_by(membership_Nclus4) %>%
  #             summarise(perc=round(n/sum(n),3), membership_Nclus5=membership_Nclus5) %>%
  #             arrange(desc(membership_Nclus5), .by_group = TRUE) ,
  #           aes(x = membership_Nclus4, label = scales::percent(perc), y=perc, fill=NULL),
  #           position = position_stack(), size=2.5)+
  xlab("")+
  theme_bw()+
  theme(legend.position = 'none',
        panel.grid  = element_blank(),
        # axis.text = element_blank(),
        axis.text.y = element_blank(),
        axis.title = element_blank(),
        axis.title.y = element_blank(),
        axis.ticks.y = element_blank())

### Right spine
g2 = data_2_right %>%
  # mutate(membership=factor(membership,levels=c(0,1,2,3,4))) %>%
  ggplot(mapping = aes(fill=membership_Nclus5,x=membership_Nclus4)) +
  scale_fill_manual(values=fill_color) +
  geom_bar(position="stack") +
  # geom_text(data = data_2_left %>%
  #             count(membership_Nclus4, membership_Nclus5) %>% group_by(membership_Nclus4) %>%
  #             summarise(perc=round(n/sum(n),3), membership_Nclus5=membership_Nclus5) %>%
  #             arrange(desc(membership_Nclus5), .by_group = TRUE) ,
  #           aes(x = membership_Nclus4, label = scales::percent(perc), y=perc, fill=NULL),
  #           position = position_stack(), size=2.5)+
  xlab("")+
  theme_bw()+
  theme(legend.position = 'none',
        panel.grid  = element_blank(),
        # axis.text = element_blank(),
        axis.text.y = element_blank(),
        axis.title = element_blank(),
        axis.title.y = element_blank(),
        axis.ticks.y = element_blank())

grid.arrange(g1, g2, ncol=2)
```

- From 5-cluster to 4-cluster result, a large proportion of 3rd cluster merge with 4th cluster. 
- Some nodes in 2nd cluster join 1st cluster. Leading to improvement in consistency: the connecting probabilities $p_{1,3}>p_{2,3}$ for both Left and Right spine.


## Visualize estimated time shifts
```{r}
### Get memberships for ALL nodes
membership_list = lapply(clusters_list, clus2mem)
membership_list[[1]] = clus2mem(clusters_list[[1]][order_clus_1])
membership_list[[2]] = clus2mem(clusters_list[[2]][order_clus_2])

# for (m in 1:length(membership_list)) {
#   N_node = nrow(locs_mat_list[[m]])
#   mem_tmp = rep(0,N_node)
#   mem_tmp[non_iso_inds_list[[m]]] = membership_list[[m]]
#   membership_list[[m]] = mem_tmp
# }

### Plot time shifts distribution
data = tibble(v_vec=unlist(v_vec_list),
              membership=unlist(membership_list),
              subj=rep(1:length(v_vec_list), times=sapply(v_vec_list,length)))

g5 <- data %>%
  filter(membership<=3) %>%
  group_by(membership) %>%
  mutate(N_node = n()) %>%
  ggplot(aes(x=v_vec,group=as.factor(membership),
             size=N_node,
             color=as.factor(membership)))+
  geom_density( aes(), alpha=0.6) +
  scale_color_manual(values=palette()[1+1:4]) +
  scale_fill_manual(values=palette()[1+1:4]) +
  scale_size(range=c(0.3,1)) +
  theme_bw()+
  theme(legend.position = "none") +
  # facet_wrap(~subj) +
  scale_x_continuous() +
  theme(axis.ticks.y = element_blank(), 
              axis.text.y = element_blank(), 
              axis.title.y = element_blank(),
              axis.ticks.x = element_blank(), 
              axis.text.x = element_blank(), 
              axis.title.x = element_blank()) +
  xlab('Time shifts (min)')

print(g5)
```


```{r}
### Get Wan's result
dat=readMat(paste('../../Raw_data/to_shizhe/','Leader_',
                  substr(params$subj_name, start=nchar(params$subj_name)-7,
                         stop=nchar(params$subj_name)),
                  '.mat',sep=''))
activeTime_vec = dat$activeTime * 60
# activeTime_vec = activeTime_vec[c(inds_L[non_iso_inds_L],
#                                   inds_R[non_iso_inds_R])]
activeTime_vec = activeTime_vec[c(inds_L[avai_inds_L],
                                  inds_R[avai_inds_R])]

data = tibble(v_vec=activeTime_vec,
              membership=unlist(membership_list),
              subj=rep(1:length(v_vec_list), times=sapply(v_vec_list,length)))

g6 <- data %>%
  filter(membership<=3) %>%
  group_by(membership) %>%
  mutate(N_node = n()) %>%
  ggplot(aes(x=v_vec,group=as.factor(membership),
             size=N_node,
             color=as.factor(membership)))+
  geom_density( aes(), alpha=0.6, linetype=2) +
  scale_color_manual(values=palette()[1+1:4]) +
  scale_fill_manual(values=palette()[1+1:4]) +
  scale_size(range=c(0.3,1)) +
  theme_bw()+
  theme(legend.position = "none") +
  # facet_wrap(~subj) +
  scale_x_continuous() +
  # theme(axis.ticks.y = element_blank(),
  #             axis.text.y = element_blank(),
  #             axis.title.y = element_blank(),
  #             axis.ticks.x = element_blank(),
  #             axis.text.x = element_blank(),
  #             axis.title.x = element_blank()) +
  ggtitle("Wan's activation time") +
  xlab('Time shifts (min)')
print(g6)
```

```{r}
# g_list_2 = c(g_list,list(g5))
# layout_mat = matrix(NA,3,3)
# layout_mat[lower.tri(layout_mat, diag = TRUE)] = 1:6
# layout_mat[1,2]=7
# g = arrangeGrob(grobs=g_list_2, layout_matrix=layout_mat)
# grid.arrange(g)
# 
```


## Visualize estimated clusters with spatial location

```{r}

### Spatial location  ----

data = as.data.frame(rbind(locs_mat_L[avai_inds_L,],
                           locs_mat_R[avai_inds_R,]))
colnames(data) = c('AP','LR','DV')
data = cbind(data,
             membership=unlist(membership_list),
             membership_Nclus5 = unlist(membership_list_Nclus5),
             subj=rep(1:length(membership_list),
                      times=sapply(membership_list,length)))
data = data %>%
  filter(membership <= 3) %>%
  mutate(membership=as_factor(membership),
         membership_Nclus5=as_factor(membership_Nclus5))
fig = plot_ly(data, x = ~LR, y = ~AP, z = ~DV, 
              color = ~membership,
              colors = c(`0`=palette()[8],
                         `1`=palette()[2],
                         `2`=palette()[3],
                         `3`=palette()[4],
                         `4`=palette()[5],
                         `5`=palette()[6]),
              # symbol = ~membership_Nclus5,
              # symbols = c(`1`=16,
              #             `2`=17,
              #             `3`=18,
              #             `4`=4,
              #             `5`=5),
              type = "scatter3d")
# fig = fig %>% add_trace(type='scatter3d', symbol=~membership_Nclus5)
fig = fig %>%
  layout(scene = list(aspectmode='manual', aspectratio = list(x=1.5, y=1, z=1)))
fig
```


<!-- ```{r} -->
<!-- which(locs_mat[,3]>64) -> ind_top -->
<!-- which(locs_mat[,3]<=64 & locs_mat[,2]>0) -> ind_L -->
<!-- which(locs_mat[,3]<=64 & locs_mat[,2]<0) -> ind_R -->

<!-- edge_time_mat[ind_top,ind_top] -> mat1 -->
<!-- edge_time_mat[ind_L,ind_L] -> mat2 -->
<!-- edge_time_mat[ind_R,ind_R] -> mat3 -->

<!-- plot(density(mat2[mat2<Inf]),ylim=c(0,0.008)) -->
<!-- lines(density(mat3[mat3<Inf]),lty=2) -->
<!-- lines(density(mat1[mat1<Inf]),lty=3,col=2) -->

<!-- mnx_vec[ind_top] -->
<!-- ``` -->

## Associated estimated clusters with mnx+/- indicator

There are 3 mnx- neurons, all from Left spine. 2 of them are in 4th cluster, the other one is in 3rd cluster.
